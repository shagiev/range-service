# Сервис выбора уникальных чисел из диапазона целых чисел.

## Вариант 1. PHP + хранимые процедуры в Postgres

Надежное хранение состояния в персистентном хранилище, защита от коллизий.

Числа выдаются в случайном порядке, чтобы обезопаситься от возможных атак последовательного перебора.
Для хранения состояния используется принцип Fisher-Yates shuffle. На каждом шаге выдается случайное число из свободных, а на его место кладется лежащее последним.
При этом хранятся только те числа, которые лежат не на своем месте после перестановки. Благодаря этому в худшем случае нам всегда надо хранить не больше чем min(количество занятых, количество свободных).

Миграция БД в db, код сервиса в src. Тесты в tests, web-сервис - public/index.php, CLI-скрипт - cli/range-service.php.

Как масштабировать: при увеличении нагрузки есть два различных варианта: 1) если мы имеем много отдельных диапазонов, разные диапазоны можно безболезненно разделять на разные серверы, также как и приложение, которое является тонким клиентом без собственного состояния. Можно ипользовать nginx как reverse-proxy для балансировки нагрузки. 2) Если будет небольшое количество диапазонов с большим количеством запросов внутри, каждый диапазон можно разделять на разные машины. При операции allocate отправляем поочередно запросы на разные ноды, каждая выдает только из своего поддиапазона (сложность будет только при ситуации, когда закончатся числа на определенных нодах, придется держать кэш законченных поддиапазонов), при операции release обращаемся прямо к нужной ноде, где должны храниться данные об этом числе.

Минусы: код хранимых процедур сложно поддерживать, работа с реляционной СУБД относительно медленная, зависимость от конкретной СУБД.


## Вариант 2. JVM-решение (не завершено)

Высокая скорость работы по сравнению с хранением состояния в СУБД. 
Все состояние хранится в самом приложении. Для сохранения состояния на случай смерти процесса предполагалось добавить key-value хранилище, в которое отдельным потоком сохраняются изменения состояния, а при перезапуске процесса из него восстанавливается состояние. 
Для хранения состояния используется тот же принцип тасования. 
При росте нагрузки можно использовать балансировщик нагрузки, разделяющий диапазоны на приложения. Если приходится высокая нагрузка на отдельные диапазоны, можно разделить его на поддиапазоны.
Минус: возможность потери данных.
